"use strict";(self.webpackChunklowcode_platform_docs=self.webpackChunklowcode_platform_docs||[]).push([["2036"],{7742:function(n,r,e){e.r(r),e.d(r,{default:()=>t});var i=e("2676"),a=e("453");let d=e.p+"static/image/editor-sandbox.a038629b.png";function o(n){let r=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",div:"div",h3:"h3",pre:"pre",code:"code",img:"img"},(0,a.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.h1,{id:"沙箱",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#沙箱",children:"#"}),"沙箱"]}),"\n",(0,i.jsxs)(r.h2,{id:"概述",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#概述",children:"#"}),"概述"]}),"\n",(0,i.jsx)(r.p,{children:"因编辑器输入代码的不可信任，所以需要一个沙箱环境来执行代码, 防止程序访问 / 影响主页面, 主要用于隔离搭建侧和画布预览侧的作用域。"}),"\n",(0,i.jsxs)(r.div,{className:"rspress-directive tip",children:[(0,i.jsx)(r.div,{className:"rspress-directive-title",children:"TIP"}),(0,i.jsx)(r.div,{className:"rspress-directive-content",children:(0,i.jsx)(r.p,{children:"在计算机安全中，沙箱（Sandbox）是一种用于隔离正在运行程序的安全机制，通常用于执行未经测试或不受信任的程序或代码，它会为待执行的程序创建一个独立的执行环境，内部程序的执行不会影响到外部程序的运行"})})]}),"\n",(0,i.jsx)(r.p,{children:"画布使用了最传统的 Iframe 方案，它的兼容性最好，功能最完善（沙箱做的最彻底，js 作用域、css 隔离等），但此处还是列举了几个社区中其他的沙箱方案。"}),"\n",(0,i.jsxs)(r.h2,{id:"其他方案",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#其他方案",children:"#"}),"其他方案"]}),"\n",(0,i.jsxs)(r.h3,{id:"proxy-sandbox",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#proxy-sandbox",children:"#"}),"Proxy Sandbox"]}),"\n",(0,i.jsx)(r.p,{children:"可以通过代理 Proxy 实现对象的劫持，通过 window 对象的修改进行记录，在卸载时删除这些记录，在应用再次激活时恢复这些记录，来达到模拟沙箱环境的目的。"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",meta:"",children:"// 修改 window 属性的公共方法\r\nconst updateHostProp = (prop: any, value, isDel?) => {\r\n  if (value === undefined || isDel) {\r\n    delete window[prop];\r\n  } else {\r\n    window[prop] = value;\r\n  }\r\n};\r\n\r\nclass ProxySandbox {private currentUpdatedPropsValueMap = new Map()\r\n    private modifiedPropsMap = new Map()\r\n    private addedPropsMap = new Map()\r\n    public name: string = \"\";\r\n    public proxy: any;\r\n\r\n    /**\r\n     * 激活沙箱\r\n     */\r\n    public active() {\r\n        // 根据记录还原沙箱\r\n        this.currentUpdatedPropsValueMap.forEach((v, p) => updateHostProp(p, v));\r\n    }\r\n\r\n    /**\r\n     * 关闭沙箱\r\n     */\r\n    public inactive() {\r\n        // 1 将沙箱期间修改的属性还原为原先的属性\r\n        this.modifiedPropsMap.forEach((v, p) => updateHostProp(p, v));\r\n        // 2 将沙箱期间新增的全局变量消除\r\n        this.addedPropsMap.forEach((_, p) => updateHostProp(p, undefined, true));\r\n    }\r\n\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.proxy = null;\r\n        // 存放新增的全局变量\r\n        this.addedPropsMap  = new Map();\r\n        // 存放沙箱期间更新的全局变量\r\n        this.modifiedPropsMap = new Map();\r\n        // 存在新增和修改的全局变量，在沙箱激活的时候使用\r\n        this.currentUpdatedPropsValueMap = new Map();\r\n\r\n        const {addedPropsMap, currentUpdatedPropsValueMap, modifiedPropsMap} = this;\r\n        const fakeWindow = Object.create(null);\r\n        const proxy = new Proxy(fakeWindow, {set(target, prop, value) {if (!window.hasOwnProperty(prop)) {\r\n                    // 如果 window 上没有的属性，记录到新增属性里\r\n                    addedPropsMap.set(prop, value);\r\n                } else if (!modifiedPropsMap.has(prop)) {\r\n                    // 如果当前 window 对象有该属性，且未更新过，则记录该属性在 window 上的初始值\r\n                    const originalValue = window[prop];\r\n                    modifiedPropsMap.set(prop, originalValue);\r\n                }\r\n                // 记录修改属性以及修改后的值\r\n                currentUpdatedPropsValueMap.set(prop, value);\r\n                // 设置值到全局 window 上\r\n                updateHostProp(prop, value);\r\n                return true;\r\n            },\r\n            get(target, prop) {return window[prop];\r\n            },\r\n        });\r\n        this.proxy = proxy;\r\n    }\r\n}\r\n\r\nconst newSandBox: ProxySandbox = new ProxySandbox(' 代理沙箱 ');\r\nconst proxyWindow = newSandBox.proxy;\r\nproxyWindow.a = '1';\r\nconsole.log(' 开启沙箱：', proxyWindow.a, window.a);\r\nnewSandBox.inactive(); // 失活沙箱\r\nconsole.log(' 失活沙箱：', proxyWindow.a, window.a);\r\nnewSandBox.active(); // 失活沙箱\r\nconsole.log(' 重新激活沙箱：', proxyWindow.a, window.a);\r\n\n"})}),"\n",(0,i.jsx)(r.p,{children:"以上代码实现了基础版的沙箱，通过 active 方法开始沙箱代理，社区中的 qiankunu 等此类的微前端架构中基本都采用了此类的设计。"}),"\n",(0,i.jsxs)(r.h3,{id:"diff-sandbox",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#diff-sandbox",children:"#"}),"Diff Sandbox"]}),"\n",(0,i.jsx)(r.p,{children:"除 Proxy 方式外，我们可以通过 diff 的方式创建沙箱，一般作为 Proxy Sandbox 的降级方案，在应用运行的时候保存一个快照 window 对象，将当前 window 对象的全部属性都复制到快照对象上，子应用卸载的时候将 window 对象修改做个 diff，将不同的属性用个 modifyMap 保存起来，再次挂载的时候再加上这些修改的属性。"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",meta:"",children:"class DiffSandbox {\r\n    public name: any;\r\n    public modifyMap: {};\r\n    private windowSnapshot: {};\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.modifyMap = {}; // 存放修改的属性\r\n        this.windowSnapshot = {};}\r\n    public active() {\r\n        // 缓存 active 状态的沙箱\r\n        this.windowSnapshot = {};\r\n        for (const item in window) {this.windowSnapshot[item] = window[item];\r\n        }\r\n\r\n        Object.keys(this.modifyMap).forEach(p => {window[p] = this.modifyMap[p];\r\n        });\r\n\r\n    }\r\n\r\n    public inactive() {for (const item in window) {if (this.windowSnapshot[item] !== window[item]) {\r\n                // 记录变更\r\n                this.modifyMap[item] = window[item];\r\n                // 还原 window\r\n                window[item] = this.windowSnapshot[item];\r\n            }\r\n        }\r\n    }\r\n}\r\nconst diffSandbox = new DiffSandbox('diff 沙箱 ');\r\ndiffSandbox.active();  // 激活沙箱\r\nwindow.a = '1';\r\nconsole.log(' 开启沙箱：', window.a);\r\ndiffSandbox.inactive(); // 失活沙箱\r\nconsole.log(' 失活沙箱：', window.a);\r\ndiffSandbox.active();   // 重新激活\r\nconsole.log(' 再次激活 ', window.a);\r\n\n"})}),"\n",(0,i.jsxs)(r.h2,{id:"画布沙箱",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#画布沙箱",children:"#"}),"画布沙箱"]}),"\n",(0,i.jsxs)(r.h3,{id:"方案设计",children:[(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#方案设计",children:"#"}),"方案设计"]}),"\n",(0,i.jsx)(r.p,{children:"画布沙箱和低代码平台处于同域，因此不会存在跨域无法操作沙箱 dom 的问题，仅仅作为隔离 javascript、style 的容器。"}),"\n",(0,i.jsx)(r.div,{className:"my-4 flex flex-row justify-center",children:(0,i.jsx)(r.img,{alt:"画布沙箱",src:d})})]})}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,a.ah)(),n.components);return r?(0,i.jsx)(r,Object.assign({},n,{children:(0,i.jsx)(o,n)})):o(n)}let t=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["guide%2Fframework%2Fsandbox.mdx"]={toc:[{id:"概述",text:"概述",depth:2},{id:"其他方案",text:"其他方案",depth:2},{id:"proxy-sandbox",text:"Proxy Sandbox",depth:3},{id:"diff-sandbox",text:"Diff Sandbox",depth:3},{id:"画布沙箱",text:"画布沙箱",depth:2},{id:"方案设计",text:"方案设计",depth:3}],title:"沙箱",frontmatter:{}}}}]);