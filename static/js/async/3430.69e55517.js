"use strict";(self.webpackChunklowcode_platform_docs=self.webpackChunklowcode_platform_docs||[]).push([["3430"],{7755:function(e,r,n){n.r(r),n.d(r,{default:()=>d});var s=n("2676"),a=n("453");let t=n.p+"static/image/code-ast.d94119ad.png",i=n.p+"static/image/result-render.ff208b60.png";function c(e){let r=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ol:"ol",li:"li",div:"div",img:"img",pre:"pre",code:"code",details:"details",summary:"summary",h3:"h3",h4:"h4",h5:"h5"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"物料dsl解析",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#物料dsl解析",children:"#"}),"物料DSL解析"]}),"\n",(0,s.jsxs)(r.h2,{id:"概述",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#概述",children:"#"}),"概述"]}),"\n",(0,s.jsx)(r.p,{children:"当前业内大多数低代码平台的物料配置项通常通过 JSON Schema 来描述。这种方式虽然灵活，但在实际开发中存在一些明显的痛点："}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"学习成本高：特别是对于拥有复杂配置项的物料，理解和手写 Schema 需要较高的专业知识，给开发者带来了额外的负担。"}),"\n",(0,s.jsx)(r.li,{children:"重复工作量大：对于使用 TypeScript 的开发者来说，手写 JSON Schema 的过程尤为繁琐。开发者通常需要为同一个属性定义两套配置：一套是用于代码类型校验的 Interface.ts 文件，另一套是描述 Schema 的 JSON 文件，这大幅增加了开发成本。"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"通过自动化生成配置项，可以有效降低开发难度，提高开发效率，同时减少维护成本。"}),"\n",(0,s.jsxs)(r.h2,{id:"基本流程",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#基本流程",children:"#"}),"基本流程"]}),"\n",(0,s.jsx)(r.div,{className:"my-4 flex flex-row justify-center",children:(0,s.jsx)(r.img,{alt:"ast解析流程",src:t})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.a,{href:"/schema.html",children:"移步体验"}),'{:target="_blank"}']}),"\n",(0,s.jsxs)(r.h2,{id:"设计原理",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#设计原理",children:"#"}),"设计原理"]}),"\n",(0,s.jsx)(r.p,{children:"开发者可以使用 TypeScript 编写物料的 props 类型文件 (Interface.ts)，然后通过工具将其解析成 AST，再根据 AST 中的字段和注释自动生成标准的 DSL；"}),"\n",(0,s.jsx)(r.p,{children:"例如以下代码:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",meta:"",children:"\r\n/**\r\n * @Component CommonHeader\r\n * @name common-header\r\n * @title 测试组件\r\n */\r\nexport default interface CommonHeaderIProps {\r\n  /**\r\n   * 名称\r\n   *\r\n   * @title 名称\r\n   * @type string\r\n   * @default 测试\r\n   */\r\n  name?: string;\r\n  \r\n  /**\r\n   * 复选框\r\n   *\r\n   * @title 复选框\r\n   * @type string\r\n   * @widget checkbox\r\n   * @default ['1']\r\n   */\r\n  checkbox?: TestSelectValue[];\r\n}\r\n\r\nenum TestSelectValue {\r\n  test1 = '1',\r\n  test2 = '2',\r\n  test3 = '3',\r\n}\r\n\n"})}),"\n",(0,s.jsx)(r.p,{children:"通过解析后生成如下的 DSL:"}),"\n",(0,s.jsxs)(r.details,{className:"rspress-directive details",children:[(0,s.jsx)(r.summary,{className:"rspress-directive-title",children:"DETAILS"}),(0,s.jsx)(r.div,{className:"rspress-directive-content",children:(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-json",meta:"",children:'{\r\n  "name": "example-test-com",\r\n  "libName": "ExampleTestCom",\r\n  "version": "1.0.0",\r\n  "author": "Marvin",\r\n  "description": "",\r\n  "keywords": [],\r\n  "schema": [\r\n    {\r\n      "componentName": "StringSetter",\r\n      "props": {\r\n        "formItemProps": {\r\n          "label": "名称",\r\n          "name": "name"\r\n        },\r\n        "setter": "StringSetter"\r\n      }\r\n    },\r\n    {\r\n      "componentName": "CheckboxSetter",\r\n      "props": {\r\n        "formItemProps": {\r\n          "label": "复选框",\r\n          "name": "checkbox"\r\n        },\r\n        "options": [\r\n          {\r\n            "label": "test1",\r\n            "value": "1"\r\n          },\r\n          {\r\n            "label": "test2",\r\n            "value": "2"\r\n          },\r\n          {\r\n            "label": "test3",\r\n            "value": "3"\r\n          }\r\n        ],\r\n        "setter": "CheckboxSetter"\r\n      }\r\n    }\r\n  ],\r\n  "defaultValue": {\r\n    "name": "测试",\r\n    "checkbox": [\r\n      "1"\r\n    ]\r\n  }\r\n}\n'})})})]}),"\n",(0,s.jsx)(r.p,{children:"最后通过 DSL json 渲染的效果类似："}),"\n",(0,s.jsx)(r.div,{className:"my-4 flex flex-row justify-center",children:(0,s.jsx)(r.img,{alt:"render",src:i})}),"\n",(0,s.jsxs)(r.h3,{id:"ast-解析",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#ast-解析",children:"#"}),"AST 解析"]}),"\n",(0,s.jsxs)(r.h4,{id:"常见的方案",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#常见的方案",children:"#"}),"常见的方案"]}),"\n",(0,s.jsx)(r.p,{children:"业内解析代码生成Ast 的工具非常多。"}),"\n",(0,s.jsxs)(r.h5,{id:"babel",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#babel",children:"#"}),"Babel"]}),"\n",(0,s.jsx)(r.p,{children:"广泛用于 ES6+ 转换为 ES5，代码转译、优化和静态分析， 适合处理 JavaScript/TypeScript 代码的语法转换与优化。"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"@babel/parser：解析代码生成 AST；"}),"\n",(0,s.jsx)(r.li,{children:"@babel/traverse：对 AST 进行遍历，修改节点；"}),"\n",(0,s.jsx)(r.li,{children:"@babel/types：用于生成或修改 AST 节点；"}),"\n",(0,s.jsx)(r.li,{children:"@babel/generator：将 AST 转回代码；"}),"\n"]}),"\n",(0,s.jsxs)(r.h5,{id:"acorn",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#acorn",children:"#"}),"Acorn"]}),"\n",(0,s.jsx)(r.p,{children:"轻量级、高性能的 JavaScript 解析器， 需要自定义的语法扩展或极高的性能需求。"}),"\n",(0,s.jsxs)(r.h5,{id:"swc",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#swc",children:"#"}),"SWC"]}),"\n",(0,s.jsx)(r.p,{children:"基于 Rust 的高性能 JavaScript/TypeScript 转译器，支持解析和生成 AST， 性能远超 Babel，适合需要高性能的大规模代码解析与转换。"}),"\n",(0,s.jsxs)(r.h5,{id:"typescript-compiler-api",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#typescript-compiler-api",children:"#"}),"TypeScript Compiler API"]}),"\n",(0,s.jsx)(r.p,{children:"能解析 TypeScript 代码为 AST， 适合对 TypeScript 代码的深度解析和类型分析。"}),"\n",(0,s.jsxs)(r.h4,{id:"最佳选择",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#最佳选择",children:"#"}),"最佳选择"]}),"\n",(0,s.jsxs)(r.p,{children:["此转换工具只用通过分析 AST 查找字段类型，不用修改源码，比较适合通过 TypeScript Compiler 实现。 TypeScript Compiler API 官方提供的文档只有一个 wiki，",(0,s.jsx)(r.a,{href:"https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API",rel:"noopener noreferrer",target:"_blank",children:"TypeScript Compiler API"}),"， 感兴趣的可以研究研究。"]}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"createSourceFile"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",meta:"",children:"const fileName = 'example.ts';\r\nconst content = readFileSync('./interface.ts', 'utf-8');\r\nconst sourceFile = ts.createSourceFile(fileName, content, ts.ScriptTarget.Latest, true);\n"})}),"\n",(0,s.jsxs)(r.ol,{start:"2",children:["\n",(0,s.jsx)(r.li,{children:"forEachChild"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",meta:"",children:"ts.forEachChild(sourceFile, (node: { kind: any; }) => {\r\n  // 分析每一个node\r\n});\n"})}),"\n",(0,s.jsxs)(r.ol,{start:"3",children:["\n",(0,s.jsx)(r.li,{children:"SyntaxKind.InterfaceDeclaration"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"对于 interface 关键字段做分析处理。"}),"\n",(0,s.jsxs)(r.ol,{start:"4",children:["\n",(0,s.jsx)(r.li,{children:"SyntaxKind.EnumDeclaration"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"对于 enum 关键字段做分析处理。"}),"\n",(0,s.jsxs)(r.ol,{start:"4",children:["\n",(0,s.jsx)(r.li,{children:"SyntaxKind.TypeAliasDeclaration、SyntaxKind.FunctionType"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"对于函数类型做分析处理。"}),"\n",(0,s.jsxs)(r.h3,{id:"元数据解析",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#元数据解析",children:"#"}),"元数据解析"]}),"\n",(0,s.jsx)(r.p,{children:"元数据解析主要负责解析物料的基本信息，包括物料名称、物料描述、物料版本、物料的每一个配置项等。"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"通过 ts 提供的 getJSDocTags Api 获取字段对应的注释；"}),"\n",(0,s.jsx)(r.li,{children:"然后逐一解析每一行注释，提取出字段的名称、已经对应的值；"}),"\n"]}),"\n",(0,s.jsxs)(r.h4,{id:"核心实现",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#核心实现",children:"#"}),"核心实现"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",meta:"",children:"// 逐一解析每一行注释\r\nfunction parseJSDocCommentV2(docTags: readonly JSDocTag[]): Record<string, any> {\r\n  const result: Record<string, any> = {};\r\n  docTags.forEach(item => {\r\n    if (item.tagName.escapedText) {\r\n      result[item.tagName.escapedText] = item.comment\r\n    }else {\r\n      console.log(item)\r\n    }\r\n  })\r\n  return result;\r\n}\r\n\r\nconst jsdoc = ts.getJSDocTags(node);\r\nconst schema: Record<string, any> = {\r\n  type: 'object',\r\n  properties: {},\r\n  required: [],\r\n};\r\nconst property = parseJSDocCommentV2(jsdoc);\r\nfor(const key in property) {\r\n   // 标记解析的入口\r\n   if (key === 'Component') {\r\n      schema[key] = true\r\n   } else {\r\n      schema[key] = property[key]\r\n   }\r\n}\r\n\n"})})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,a.ah)(),e.components);return r?(0,s.jsx)(r,Object.assign({},e,{children:(0,s.jsx)(c,e)})):c(e)}let d=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["guide%2Fframework%2Ftype-to-ast.md"]={toc:[{id:"概述",text:"概述",depth:2},{id:"基本流程",text:"基本流程",depth:2},{id:"设计原理",text:"设计原理",depth:2},{id:"ast-解析",text:"AST 解析",depth:3},{id:"常见的方案",text:"常见的方案",depth:4},{id:"最佳选择",text:"最佳选择",depth:4},{id:"元数据解析",text:"元数据解析",depth:3},{id:"核心实现",text:"核心实现",depth:4}],title:"物料DSL解析",frontmatter:{}}}}]);